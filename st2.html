<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Wireframe Galaxy — True 3D Infinite Rotation ☣</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    color: #9f9;
    font-family: system-ui, monospace;
    overflow: hidden;
  }
  #hud {
    position: fixed;
    left: 12px;
    top: 10px;
    user-select: none;
    pointer-events: none;
    font-size: 13px;
    line-height: 1.35;
    background: rgba(0,0,0,0.35);
    padding: 8px 10px;
    border: 1px solid #073;
    border-radius: 8px;
    text-shadow: 0 0 6px #0f0;
  }
  #titlebar {
    position: fixed;
    top: 0;
    width: 100%;
    text-align: center;
    padding: 8px 0 6px;
    font-weight: 700;
    letter-spacing: 0.06em;
    user-select: none;
    pointer-events: none;
    text-shadow: 0 0 8px #0f0, 0 0 14px #090;
  }
  canvas { display:block; width:100%; height:100%; }
</style>
</head>
<body>
<div id="titlebar">WIREFRAME GALAXY — full 3D spin ◀ ▶ ▲ ▼, zoom + / −, ☣ Cleoms visible on close zoom</div>
<canvas id="c"></canvas>
<div id="hud"></div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });
  const hud = document.getElementById('hud');

  function resize() {
    const dpr = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }
  addEventListener('resize', resize);
  resize();

  // --- galaxy stars ---
  const STAR_COUNT = 2000;
  const stars = [];
  for (let i = 0; i < STAR_COUNT; i++) {
    const u = Math.random();
    const r = Math.pow(u, 0.55);
    const arm = i % 2;
    const base = (arm ? 0 : Math.PI) + r * 6;
    const t = base + (Math.random() - 0.5) * 0.35;
    const x = r * Math.cos(t);
    const y = r * Math.sin(t);
    const z = (Math.random() - 0.5) * 0.06 * (1 - r * 0.7);
    const b = 0.6 + 0.4 * (1 - r);
    stars.push({ x, y, z, b });
  }

  // --- Cleoms ---
  const CLEOM_COUNT = 40;
  const cleoms = [];
  for (let i = 0; i < CLEOM_COUNT; i++) {
    const r = Math.random() * 0.9 + 0.1;
    const theta = Math.random() * Math.PI * 2;
    const x = r * Math.cos(theta);
    const y = r * Math.sin(theta);
    const z = (Math.random() - 0.5) * 0.05;
    cleoms.push({ x, y, z });
  }

  // --- camera ---
  let yaw = 0, pitch = 0;
  let zoom = 1, targetZoom = 1;
  let panX = 0, panY = 0, targetPanX = 0, targetPanY = 0;
  const KEY = {};
  const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));

  addEventListener('keydown', e => {
    if (['ArrowLeft','ArrowRight','ArrowUp','ArrowDown','+','-','z','Z'].includes(e.key)) e.preventDefault();
    KEY[e.key] = true;
  });
  addEventListener('keyup', e => { KEY[e.key] = false; });

  // --- zoom centered ---
  canvas.addEventListener('wheel', e => {
    e.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    const mx = e.clientX - rect.left - cx - panX;
    const my = e.clientY - rect.top - cy - panY;
    const factor = Math.exp(-e.deltaY * 0.0015);
    const newZoom = clamp(targetZoom * factor, 0.2, 8);
    const k = newZoom / targetZoom;
    targetPanX -= mx * (k - 1);
    targetPanY -= my * (k - 1);
    targetZoom = newZoom;
  }, { passive:false });

  // --- click to center / double-click zoom ---
  let lastClick = 0;
  canvas.addEventListener('click', e => {
    const now = performance.now();
    const rect = canvas.getBoundingClientRect();
    const cx = rect.width/2, cy = rect.height/2;
    targetPanX = e.clientX - rect.left - cx;
    targetPanY = e.clientY - rect.top - cy;
    if (now - lastClick < 300) targetZoom = clamp(targetZoom * 1.6, 0.2, 8);
    lastClick = now;
  });

  // --- rotation matrix ---
  function rotatePoint(p, yaw, pitch) {
    const cy = Math.cos(yaw), sy = Math.sin(yaw);
    const cp = Math.cos(pitch), sp = Math.sin(pitch);
    // apply yaw then pitch
    const x1 = p.x * cy - p.z * sy;
    const z1 = p.x * sy + p.z * cy;
    const y1 = p.y * cp - z1 * sp;
    const z2 = p.y * sp + z1 * cp;
    return { x: x1, y: y1, z: z2 };
  }

  function drawGrid(scale, cx, cy) {
    ctx.save();
    ctx.translate(cx + panX, cy + panY);
    ctx.strokeStyle = 'rgba(0,255,140,0.18)';
    for (let i = 1; i <= 10; i++) {
      const rr = (i/10) * scale;
      ctx.beginPath();
      ctx.ellipse(0, 0, rr, rr, 0, 0, Math.PI*2);
      ctx.stroke();
    }
    ctx.strokeStyle = 'rgba(0,255,140,0.35)';
    ctx.beginPath();
    ctx.arc(0, 0, scale, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  function drawStars(scale, cx, cy) {
    ctx.save();
    ctx.translate(cx + panX, cy + panY);
    for (const s of stars) {
      const r = rotatePoint(s, yaw, pitch);
      const sx = r.x * scale;
      const sy = r.y * scale;
      const size = s.b * 2 * zoom;
      ctx.globalAlpha = 0.35 + s.b * 0.65;
      ctx.fillStyle = '#9f9';
      ctx.fillRect(sx - size/2, sy - size/2, size, size);
    }
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  function drawCleoms(scale, cx, cy) {
    if (zoom < 2.0) return;
    ctx.save();
    ctx.translate(cx + panX, cy + panY);
    for (const c of cleoms) {
      const r = rotatePoint(c, yaw, pitch);
      const sx = r.x * scale;
      const sy = r.y * scale;
      const size = 12 * Math.sqrt(zoom);
      ctx.font = `${size}px sans-serif`;
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#0f0';
      ctx.shadowColor = '#0f0';
      ctx.shadowBlur = 10;
      ctx.globalAlpha = 0.9;
      ctx.fillText('☣', sx, sy);
    }
    ctx.shadowBlur = 0;
    ctx.globalAlpha = 1;
    ctx.restore();
  }

  // --- controls ---
  function update(dt) {
    const rs = 1.2, ts = 0.9;
    if (KEY.ArrowLeft) yaw -= rs * dt;
    if (KEY.ArrowRight) yaw += rs * dt;
    if (KEY.z || KEY.Z) {
      if (KEY.ArrowUp) targetZoom = clamp(targetZoom * 1.03, 0.2, 8);
      if (KEY.ArrowDown) targetZoom = clamp(targetZoom / 1.03, 0.2, 8);
    } else {
      if (KEY.ArrowUp) pitch -= ts * dt;
      if (KEY.ArrowDown) pitch += ts * dt;
    }
    if (KEY['+'] || KEY['=']) targetZoom = clamp(targetZoom * 1.02, 0.2, 8);
    if (KEY['-']) targetZoom = clamp(targetZoom / 1.02, 0.2, 8);
    // keep angles within safe numeric range
    if (yaw > Math.PI * 4 || yaw < -Math.PI * 4) yaw = 0;
    if (pitch > Math.PI * 4 || pitch < -Math.PI * 4) pitch = 0;

    zoom += (targetZoom - zoom) * (1 - Math.pow(0.001, dt));
    panX += (targetPanX - panX) * (1 - Math.pow(0.0015, dt));
    panY += (targetPanY - panY) * (1 - Math.pow(0.0015, dt));
  }

  // --- main loop ---
  let last = performance.now();
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    update(dt);

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const cx = canvas.width / (2 * (window.devicePixelRatio || 1));
    const cy = canvas.height / (2 * (window.devicePixelRatio || 1));
    const scale = Math.min(cx, cy) * 0.9 * zoom;

    drawGrid(scale, cx, cy);
    drawStars(scale, cx, cy);
    drawCleoms(scale, cx, cy);

    hud.innerHTML =
      `yaw: ${yaw.toFixed(2)}<br>` +
      `pitch: ${pitch.toFixed(2)}<br>` +
      `zoom: ${zoom.toFixed(2)}<br>` +
      `<span style="opacity:.75">☣ Cleoms: ${CLEOM_COUNT} (visible at zoom ≥ 2.0)</span>`;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>

